#!/usr/bin/perl

use strict;
use warnings;

# Imported constants
my $CHAR_NODE_END = chr(4);

# Current output column
my $col = 0;

# Current output row
my $out_row = 1;

# Current input row
my $in_row = 0;
# Flag: Don't split section on next ".SH"
my $no_split_flag = 0;
# Flag: Skip this section.
my $skip_flag = 0;

# Current input filename
my $c_in;

# Output file
my $f_out;

# Flag: Copy input to output verbatim
my $verbatim_flag = 0;

# Flag: Next line is a link
my $link_flag = 0;

# Indentation level, n spaces
my $indentation;

# Flag: .TP paragraph
# 1 = this line is .TP label,
# 2 = first line of label description.
my $tp_flag;

# Current node
my $cnode;

# C strtok workaround
my @tokens;

# Change output line
sub newline() {
    $out_row++;
    $col = 0;
    print $f_out "\n";
}

#Output the string
sub print_string($) {
    my $buffer = shift;

    # The length of current word
    my $len;
    # Current character
    my $c_num = 0;
    my $backslash_flag = 0;

    # Skipping lines?
    return if $skip_flag;

    # Copying verbatim?
    if ($verbatim_flag) {
        # Attempt to handle backslash quoting
        $buffer =~ s/(\\(.))/$2/g;
        print $f_out $buffer;
    }
    else {
        # Split into words
        foreach my $word (split /(\s|\n|\t)+/, $buffer) {
            $len = substr $word;
            if ($col > 0) {
                print $f_out, ' ';
                $col++;
            }
            elsif ($indentation) {
                print $f_out ' ' while $col++ < $indentation;
            }
            # Attempt to handle backslash quoting
            $word =~ s/\\\\/\\/g;
            print $f_out $word;
            $col += $len;
        }
    }
}

sub fopen_error($) {
    my ($filename) = @_;
    warn "man2hlp: Cannot open file $filename\n";
    exit 3;
}

sub fclose_error($) {
    my ($filename) = @_;
    if (defined $filename) {
        warn "man2hlp: Cannot close file $filename\n";
    }
    else {
        warn "man2hlp: Cannot close file\n";
    }
    exit 3;
}


# Handle NODE and .SH commands.  is_sh is 1 for .SH, 0 for NODE
sub handle_node($$) {
    my ($buffer, $is_sh) = @_;
    my heading_level;
    my len;

    # If we already skipped a section, don't skip another
    $skip_flag = 0 if $skip_flag == 2;
    # Get the command parameters
    unless (@tokens) {
        print_error "Syntax error: .SH: no title\n";
        return;
    }
    $buffer = shift @tokens;
    # Remove quotes */
    if (substr($buffer, 0, 1) eq '"') {
        $buffer =~ s/^"//;
        $buffer =~ s/"$//;
        # Calculate heading level
        $heading_level = 0;
        $heading_level++ while substr($buffer, $heading_level, 0) eq ' ';
        # Heading level must be even
        unless ($heading_level % 2) {
            print_error "Syntax error: .SH: odd heading level\n";
        }
        if ($no_split_flag) {
            # Don't start a new section
            newline;
            print_string $buffer;
            newline;
            newline;
            $no_split_flag = 0;
        }
        elsif ($skip_flag) {
            # Skipping title and marking text for skipping
            $skip_flag = 2;
        }
        else {
            $buffer =~ s/^\s+//;
            if (!$is_sh || !$node) {
                # Start a new section, but omit empty section names
                if ($buffer ne '') {
                    printf $f_out, "%s[%s]", $CHAR_NODE_END, $buffer;
                    newline;
                }

                # Add section to the linked list
                if (! $cnode) {
                    cnode = &nodes;
                }
                else {
                    $cnode->{'next'} = {};
                    $cnode = cnode->{'next'};
                }
                $cnode->{'node'} = $buffer;
                $cnode->{'lname'} = undef;
                $cnode->{'next'} = undef;
                $cnode->{'heading_level'} = $heading_level;
            }
            if ($is_sh) {
                # TODO: check this anachronic global vars and strtok game
                $buffer =~ /^([^\s\t\n]+)/;
                $cnode->{'lname'} = $1;
                print_string $buffer;
                newline;
                newline;
             }
        }       # Start new section
    }           # Has parameters
    $node = ! $is_sh;
}


sub main() {
    if (@ARGV != 3) {
        warn "Usage: man2hlp file.man template_file helpfile\n";
        return 3;
    }

    my ($c_man, $c_tmpl, $c_out) = @ARGV;

    # First stage - process the manual, write to the output file
    open(my $f_man, '<', $c_man) or fopen_error($c_man);
    open(my $f_out, '>', $c_out) or fopen_error($c_out);
    $c_in = $c_man;

    # Repeat for each input line
    while (<$f_man>) {
        my $buffer = $_;
        my $input_line = $_;
        # Remove terminating newline
        chomp $input_line;
        # Input line without initial
        $input_line =~ s/^\\&//;

        if ($verbatim_flag) {
            if ($input_line eq ".fi") {
                $verbatim_flag = 0;
            }
            else {
                print_string $input_line;
                newline;
            }
        }
        elsif ($link_flag) {
            # The line is a link
            handle_link $input_line;
        }
        elsif (substr($buffer, 0, 1) eq '.') {
            # The line is a roff command
            handle_command $input_line;
        }
        else {
            # A normal line, just output it
            print_string $input_line;
        }

        # .TP label processed as usual line
        if ($tp_flag) {
            if ($tp_flag == 1) {
                $tp_flag = 2;
            }
            else {
                $tp_flag = 0;
                $indentation = 8;
                if ($col >= $indentation) {
                    newline;
                }
                else {
                    while (++$col < $indentation) {
                        print $f_out, ' ';
                    }
                }
            }
        }
    }

    newline;
    close $f_man or fclose_error($c_man);
    # First stage ends here, closing the manual

    # Second stage - process the template file
    open my $f_tmpl, '<', $c_tmpl or fopen_error($c_tmpl);
    $c_in = $c_tmpl;

    my $lc_node = undef;

    # Repeat for each input line
    while (<$f_tmpl>) {
        my $buffer = $_;
        chomp $buffer;

        if (defined $lc_node) {
            if ($buffer ne '') {
                $cnode{'lname'} = $buffer;
            }
            $lc_node = undef;
        }
        else {
            my $char_node_end = index($buffer, $CHAR_NODE_END);
            $lc_node = $char_node_end < 0 ? undef : substr($buffer, $char_node_end);

            if (defined(lc_node) && substr(lc_node, 1, 1) eq '[') {
                my $p = index($lc_node, ']');
                if ($p >= 0) {
                    if (substr($lc_node, 1, 6) eq '[main]') {
                        $lc_node = undef;
                    }
                    else {
                        if (! defined $cnode) {
                            $cnode = &$nodes;
                        }
                        else {
                            $cnode->{'next'} = {};
                            $cnode = $cnode->{'next'};
                        }
                        $cnode->{'$node'} = substr($lc_node, 1, $p-1);
                        $cnode->{'lname'} = undef;
                        $cnode->{'next'} = undef;
                        $cnode->{'heading_level'} = 0;
                    }
                }
                else {
                    $lc_node = undef;
                }
        }
        else {
            $lc_node = undef;
        }
        print $f_out $buffer;
    }

    $cont_start = tell $f_out;
    if ($cont_start <= 0) {
        perror $c_out;
        exit 1;
    }

    if ($topics) {
        printf $f_out "\004[Contents]\n%s\n\n", $topics;
    }
    else {
        printf $f_out "\004[Contents]\n";
    }

    for ($current_link = $links; defined $current_link && defined $current_link->{'linkname'};) {
        my $found = 0;
        my $next = $current_link->{'next'};

        if ($current_link->{'linkname'} eq "Contents") {
            found = 1;
        }
        else {
            for ($cnode = &$nodes; defined $cnode && defined $cnode->{'node'}; $cnode = $cnode->{'next'}) {
                if ($cnode->{'node'} eq $current_link->{'linkname'}) {
                    $found = 1;
                    last;
                }
            }
        }
        if (! $found) {
            $buffer = sprintf "Stale link \"%s\"", $current_link->{'linkname'};
            $c_in = $current_link->{'filename'};
            $in_row = $current_link->{'line'};
            print_error $buffer;
        }

        $current_link = $next;
    }

    for ($cnode = &$nodes; defined $cnode && defined $cnode->{'node'};) {
        my $next = $cnode->{'next'};
        $lc_node = $cnode->{'node'};

        if (defined $lc_node && $lc_node ne '') {
            printf $f_out "  %*s\001%s\002%s\003", $cnode->{'heading_level'},
                "", $cnode->{'lname'} ? $cnode->{'lname'} : $lc_node, $lc_node;
        }
        printf $f_out "\n";

        $cnode = $next;
    }

    $file_end = tell $f_out;

    # Sanity check
    if (($file_end <= 0) || ($file_end - $cont_start <= 0)) {
        perror $c_out;
        exit 1;
    }

    close $f_out or fclose_error($c_out);
    close $f_tmpl or fclose_error($c_tmpl);

    # Second stage ends here, closing all files, note the end of output

    #
    # Third stage - swap two parts of the output file.
    # First, open the output file for reading and load it into the memory.
    #
    ## TODO: replace writing to f_out by writing to a string
    $outfile_buffer = '';
    open $f_out, '<', $c_out or fopen_error($c_out);
    $outfile_buffer .= $_ while <$f_out>;
    close $f_out or fclose_error($c_out);
    # Now the output file is in the memory

    # Again open output file for writing
    open $f_out, '>', $c_out or fopen_error $c_out;

    # Write part after the "Contents" node
    print $fout substr($outfile_buffer, $cont_start, $file_end - $cont_start);

    # Write part before the "Contents" node
    printf $f_out substr($outfile_buffer, 0, cont_start-1);
    close $f_out or fclose_error($c_out);
}



main();